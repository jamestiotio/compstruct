* these are some test vectors that may be helpful in
* debugging multipliers.  The tests are
*   all combinations of (0, 1, -1) * (0, 1 -1)
*   2^i * 1 for i = 0..31 
*   -1 * 2^i for i = 0..31
*   (3)<<i * 3 for i = 0..31

* allow verification, but not a real checkin
.checkoff "" "Lab #3: multiplier" 0

* instantiate alu
Xalu alufn[5:0] a[31:0] b[31:0] alu[31:0] z v n alu

* 100ns per vector
.tran 10500ns

* all multiplies (alufn = 00010) all the time
Walufn alufn[5:0] nrz(0,3.3,100n,0n,.1n,.1n) 2

* multiplicand
Wa a[31:0] nrz(0,3.3,100n,0n,.1n,.1n)
+ 0 0 0 1 1 1 -1 -1 -1
+ 0x00000001 0x00000002 0x00000004 0x00000008 0x00000010 0x00000020 0x00000040 0x00000080
+ 0x00000100 0x00000200 0x00000400 0x00000800 0x00001000 0x00002000 0x00004000 0x00008000
+ 0x00010000 0x00020000 0x00040000 0x00080000 0x00100000 0x00200000 0x00400000 0x00800000
+ 0x01000000 0x02000000 0x04000000 0x08000000 0x10000000 0x20000000 0x40000000 0x80000000
+ -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
+ 0x00000003 0x00000006 0x0000000C 0x00000018 0x00000030 0x00000060 0x000000C0 0x00000180
+ 0x00000300 0x00000600 0x00000C00 0x00001800 0x00003000 0x00006000 0x0000C000 0x00018000
+ 0x00030000 0x00060000 0x000C0000 0x00180000 0x00300000 0x00600000 0x00C00000 0x01800000
+ 0x03000000 0x06000000 0x0C000000 0x18000000 0x30000000 0x60000000 0xC0000000 0x80000000


* multiplier
Wb b[31:0] nrz(0,3.3,100n,0n,.1n,.1n)
+ 0 1 -1 0 1 -1 0 1 -1
+ 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
+ 0x00000001 0x00000002 0x00000004 0x00000008 0x00000010 0x00000020 0x00000040 0x00000080
+ 0x00000100 0x00000200 0x00000400 0x00000800 0x00001000 0x00002000 0x00004000 0x00008000
+ 0x00010000 0x00020000 0x00040000 0x00080000 0x00100000 0x00200000 0x00400000 0x00800000
+ 0x01000000 0x02000000 0x04000000 0x08000000 0x10000000 0x20000000 0x40000000 0x80000000
+ 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3

* result
.verify alu[31:0] periodic(9.9E-8,1.0000000000000001E-7)
+ 0 0 0 0 1 -1 0 -1 1
+ 0x00000001 0x00000002 0x00000004 0x00000008 0x00000010 0x00000020 0x00000040 0x00000080
+ 0x00000100 0x00000200 0x00000400 0x00000800 0x00001000 0x00002000 0x00004000 0x00008000
+ 0x00010000 0x00020000 0x00040000 0x00080000 0x00100000 0x00200000 0x00400000 0x00800000
+ 0x01000000 0x02000000 0x04000000 0x08000000 0x10000000 0x20000000 0x40000000 0x80000000
+ 0xFFFFFFFF 0xFFFFFFFE 0xFFFFFFFC 0xFFFFFFF8 0xFFFFFFF0 0xFFFFFFE0 0xFFFFFFC0 0xFFFFFF80
+ 0xFFFFFF00 0xFFFFFE00 0xFFFFFC00 0xFFFFF800 0xFFFFF000 0xFFFFE000 0xFFFFC000 0xFFFF8000
+ 0xFFFF0000 0xFFFE0000 0xFFFC0000 0xFFF80000 0xFFF00000 0xFFE00000 0xFFC00000 0xFF800000
+ 0xFF000000 0xFE000000 0xFC000000 0xF8000000 0xF0000000 0xE0000000 0xC0000000 0x80000000
+ 0x00000009 0x00000012 0x00000024 0x00000048 0x00000090 0x00000120 0x00000240 0x00000480
+ 0x00000900 0x00001200 0x00002400 0x00004800 0x00009000 0x00012000 0x00024000 0x00048000
+ 0x00090000 0x00120000 0x00240000 0x00480000 0x00900000 0x01200000 0x02400000 0x04800000
+ 0x09000000 0x12000000 0x24000000 0x48000000 0x90000000 0x20000000 0x40000000 0x80000000

* Some useful plots... you can plot additional signals by specifying
* the appropriate .plot commands in your main netlist file.

.plotdef op
+ ADD SUB MUL ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ??? ???
+ ??? ??? ??? ??? ??? ??? XOR ??? AND ??? A   ??? ??? ??? OR  ???
+ SHL SHR ??? SRA SHL SHR ??? SRA SHL SHR ??? SRA SHL SHR ??? SRA
+ ??? ??? ??? CMPEQ ??? CMPLT ??? CMPLE
+ ??? ??? ??? CMPEQ ??? CMPLT ??? CMPLE
.plot L(a[31:0])
.plot L(b[31:0])
.plot op(alufn[5:0])
.plot L(alu[31:0])
